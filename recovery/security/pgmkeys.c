#include "pgmkeys.h"
#include "common/path_opts.h"
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <md5/md5.h>
#include <hal/security.h>
#include <log.h>

//! Checksum structure information
struct checksum_info {
    unsigned char value[16]; //Checksum value
    char filename[128 - 32]; //Filename
};

//! Cleanup file descriptor
static void file_clean_up(FILE **fil) {
    if (*fil) {
        fclose(*fil);
    }
}

/** Convert hex ascii to the bin
 * @param[out] data Output data buffer
 * @param[in] size Destination buffer size
 * @param[in] string Input Ascii Hex string
 * @return converted buffer or NULL if error
 */
static uint8_t *datahex(unsigned char *data, size_t dsize, const char *string) {

    if (string == NULL) {
        return NULL;
    }

    size_t slength = strlen(string);
    if ((slength % 2) != 0) {
        return NULL;
    }
    if (dsize < slength / 2) {
        return NULL;
    }
    size_t index = 0;
    while (index < slength) {
        char c = string[index];
        int value = 0;
        if (c >= '0' && c <= '9') {
            value = (c - '0');
        } else if (c >= 'A' && c <= 'F') {
            value = (10 + (c - 'A'));
        } else if (c >= 'a' && c <= 'f') {
            value = (10 + (c - 'a'));
        } else {
            return NULL;
        }
        data[(index / 2)] += value << (((index + 1) % 2) * 4);
        index++;
    }
    return data;
}

//* Read md5 sum from file generated by md5sum
static int read_checksum(const char *sum_file, struct checksum_info *chksum) {
    char linebuf[128];
    FILE *__attribute__((__cleanup__(file_clean_up))) fil = fopen(sum_file, "r");
    if (!fil) {
        debug_log("Keys: failed to open checksum file: %s, errno: %d", sum_file, errno);
        return -errno;
    }
    if (!fgets(linebuf, sizeof linebuf, fil)) {
        debug_log("Keys: failed to read checksum file: %s, errno: %d", sum_file, errno);
        return -errno;
    }
    int ntoks = 0;
    const char *fname = NULL;
    char *sum = NULL;
    for (char *token = strtok(linebuf, " \t"); token; token = strtok(NULL, " \t"), ++ntoks) {
        if (ntoks == 0) {
            sum = token;
        } else if (ntoks == 1) {
            fname = token;
            for (char *tok = "\n\t\r"; *tok; ++tok) {
                char *del = strrchr(fname, *tok);
                if (del) {
                    *del = 0;
                }
            }
        }
    }
    if (ntoks != 2) {
        debug_log("Keys: wrong checksum file content: %s", sum_file);
        return error_pgm_keys_chksum_content_error;
    }
    // Copy filename
    strncpy(chksum->filename, fname, sizeof chksum->filename);
    chksum->filename[sizeof(chksum->filename) - 1] = '\0';
    //! Convert hex md5sum to bin md5
    if (!datahex(chksum->value, sizeof chksum->value, sum)) {
        debug_log("Keys: wrong checksum file content: %s", sum_file);
        return error_pgm_keys_chksum_content_error;
    }
    return error_pgm_keys_ok;
}

// Calculate checksum from the file
static int validate_checksum_srk_file(const char *srk_file, const char *sum_file) {
    int err;
    struct checksum_info cinfo = {};
    if ((err = read_checksum(sum_file, &cinfo))) {
        return err;
    }
    unsigned char fil_chksum[sizeof cinfo.value];
    MD5_File(fil_chksum, srk_file);
    if (strcmp(cinfo.filename, path_basename_const(srk_file)) != 0) {
        debug_log("Keys: filename mismatch: %s vs %s", cinfo.filename, path_basename_const(srk_file));
        return error_pgm_keys_mismatch_filename;
    }
    if (memcmp(fil_chksum, cinfo.value, sizeof fil_chksum) != 0) {
        debug_log("Keys: checksum mismatch: %s vs %s", cinfo.value, fil_chksum);
        return error_pgm_keys_mismatch_checksum;
    }
    return error_pgm_keys_ok;
}

// Burn efuses into hardware
static int burn_efuses_from_file(const char *srk_file) {
    if (!sec_configuration_is_open()) {
        debug_log("Keys: SRK keys already programmed in the OTP");
        return error_pgm_keys_already_programmed;
    }
    struct sec_srk_key keys = {};
    if (sec_verify_efuses(&keys)) {
        debug_log("Keys: SRK keys already programmed in the OTP");
        return error_pgm_keys_already_programmed;
    }
    FILE *__attribute__((__cleanup__(file_clean_up))) fil = fopen(srk_file, "r");
    if (!fil) {
        debug_log("Keys: failed to open keys file: %s, errno: %d", srk_file, errno);
        return -errno;
    }
    if (fread(keys.srk, sizeof keys.srk, 1, fil) != 1) {
        debug_log("Keys: failed to read keys file: %s, errno: %d", srk_file, errno);
        return -errno;
    }
    int error = 0;
    if ((error = sec_burn_srk_keys(&keys))) {
        debug_log("Keys: error burning SRK keys %d", error);
        return error;
    }
    // Lock bootloader when keys are successfully programmed
    sec_lock_bootloader();
    return error;
}

/** Program SRK fuses into the RT1051 fuses
 */
int program_keys(const struct program_keys_handle *pgm_handle) {
    int err;
    if (!pgm_handle) {
        debug_log("Keys: empty handle");
        return -EINVAL;
    }
    if (!pgm_handle->srk_file) {
        debug_log("Keys: SRK keys file not provided");
        return -EINVAL;
    }
    if (!pgm_handle->chksum_srk_file) {
        debug_log("Keys: checksum file not provided");
        return -EINVAL;
    }

    struct stat st;
    if ((err = stat(pgm_handle->srk_file, &st))) {
        if (errno != ENOENT) {
            debug_log("Keys: stat error: %d", errno);
        } else {
            debug_log("Keys: SRK keys file not found");
        }
        return -errno;
    }
    if (!S_ISREG(st.st_mode)) {
        debug_log("Keys: SRK keys file is not a regular file");
        return error_pgm_keys_no_srk_file;
    }
    static const off_t srk_file_size = 32U;
    if (st.st_size != srk_file_size) {
        debug_log("Keys: SRK keys file size mismatch: %d vs %d", st.st_size, srk_file_size);
        return error_pgm_keys_srk_key_size_error;
    }
    if ((err = stat(pgm_handle->chksum_srk_file, &st))) {
        if (errno != ENOENT) {
            debug_log("Keys: stat error: %d", errno);
        } else {
            debug_log("Keys: SRK keys checksum file not found");
        }
        return -errno;
    }
    if (!S_ISREG(st.st_mode)) {
        debug_log("Keys: SRK keys checksum file is not a regular file");
        return error_pgm_keys_no_sum_file;
    }
    static const off_t chksum_file_size = 32U;
    if (st.st_size < chksum_file_size) {
        debug_log("Keys: SRK keys file size too small: %d vs %d", st.st_size, chksum_file_size);
        return error_pgm_keys_chksum_file_size_error;
    }
    if ((err = validate_checksum_srk_file(pgm_handle->srk_file, pgm_handle->chksum_srk_file))) {
        return err;
    }
    if ((err = burn_efuses_from_file(pgm_handle->srk_file))) {
        return err;
    }
    return err;
}

// Check if key programming is needed
bool program_keys_is_needed(const struct program_keys_handle *pgm_handle) {
    if (!sec_configuration_is_open()) {
        return false;
    }
    struct stat st;
    if (stat(pgm_handle->srk_file, &st)) {
        return false;
    }
    return true;
}