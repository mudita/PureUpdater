#include "pgmkeys.h"
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <limits.h>
#include <md5/md5.h>
#include <common/path_opts.h>
#include <hal/security.h>
#include <hal/delay.h>

//! Checksum structure information
struct checksum_info
{
    unsigned char value[16]; //Checksum value
    char filename[128 - 32]; //Filename
};

//! Cleanup file descriptor
static void file_clean_up(FILE **fil)
{
    if (*fil)
    {
        fclose(*fil);
    }
}

/** Convert hex ascii to the bin
 * @param[out] data Output data bufer
 * @param[in] size Destination buffer size
 * @param[in] string Input Ascii Hex string
 * @return converted buffer or NULL if error
 */
static uint8_t *datahex(unsigned char *data, size_t dsize, const char *string)
{

    if (string == NULL)
    {
        return NULL;
    }

    size_t slength = strlen(string);
    if ((slength % 2) != 0)
    {
        return NULL;
    }
    if (dsize < slength / 2)
    {
        return NULL;
    }
    size_t index = 0;
    while (index < slength)
    {
        char c = string[index];
        int value = 0;
        if (c >= '0' && c <= '9')
        {
            value = (c - '0');
        }
        else if (c >= 'A' && c <= 'F')
        {
            value = (10 + (c - 'A'));
        }
        else if (c >= 'a' && c <= 'f')
        {
            value = (10 + (c - 'a'));
        }
        else
        {
            return NULL;
        }
        data[(index / 2)] += value << (((index + 1) % 2) * 4);
        index++;
    }
    return data;
}

//* Read md5 sum from file generated by md5sum
static int read_checksum(const char *sum_file, struct checksum_info *chksum, trace_t *trace)
{
    char linebuf[128];
    FILE *__attribute__((__cleanup__(file_clean_up))) fil = fopen(sum_file, "r");
    if (!fil)
    {
        trace_write(trace, error_pgm_keys_vfs, -errno);
        return -errno;
    }
    if (!fgets(linebuf, sizeof linebuf, fil))
    {
        trace_write(trace, error_pgm_keys_vfs, -errno);
        return -errno;
    }
    int ntoks = 0;
    const char *fname = NULL;
    char *sum = NULL;
    for (char *token = strtok(linebuf, " \t"); token; token = strtok(NULL, " \t"), ++ntoks)
    {
        if (ntoks == 0)
        {
            sum = token;
        }
        else if (ntoks == 1)
        {
            fname = token;
            for (char *tok = "\n\t\r"; *tok; ++tok)
            {
                char *del = strrchr(fname, *tok);
                if (del)
                {
                    *del = 0;
                }
            }
        }
    }
    if (ntoks != 2)
    {
        trace_write(trace, error_pgm_keys_chksum_content_error, 0);
        return error_pgm_keys_chksum_content_error;
    }
    // Copy filename
    strncpy(chksum->filename, fname, sizeof chksum->filename);
    chksum->filename[sizeof(chksum->filename) - 1] = '\0';
    //! Convert hex md5sum to bin md5
    if (!datahex(chksum->value, sizeof chksum->value, sum))
    {
        trace_write(trace, error_pgm_keys_chksum_content_error, 0);
        return error_pgm_keys_chksum_content_error;
    }
    return error_pgm_keys_ok;
}

// Calculate checksum from the file
static int validate_checksum_srk_file(const char *srk_file, const char *sum_file, trace_t *trace)
{
    int err;
    struct checksum_info cinfo = {};
    if ((err = read_checksum(sum_file, &cinfo, trace)))
    {
        return err;
    }
    unsigned char fil_chksum[sizeof cinfo.value];
    MD5_File(fil_chksum, srk_file);
    if (strcmp(cinfo.filename, path_basename_const(srk_file)) != 0)
    {
        trace_write(trace, error_pgm_keys_mismatch_filename, 0);
        return error_pgm_keys_mismatch_filename;
    }
    if (memcmp(fil_chksum, cinfo.value, sizeof fil_chksum) != 0)
    {
        trace_write(trace, error_pgm_keys_mismatch_checksum, 0);
        return error_pgm_keys_mismatch_checksum;
    }
    return error_pgm_keys_ok;
}

static const char *strerror_ext_pgm_keys(int err, int err_ext)
{
    return (err == error_pgm_keys_vfs) ? (strerror(-err_ext)) : ("");
}

static const char *strerror_pgm_keys(int err)
{
    switch ((enum program_keys_errors)err)
    {
    case error_pgm_keys_ok:
        return "SRK keys program success";
    case error_pgm_keys_vfs:
        return "Filesystem error";
    case error_pgm_keys_no_srk_file:
        return "Unable to find SRK key file";
    case error_pgm_keys_no_sum_file:
        return "Unable to find SRK checksum file";
    case error_pgm_keys_srk_key_size_error:
        return "SRK keys file length error";
    case error_pgm_keys_chksum_file_size_error:
        return "SRK checksum file length error";
    case error_pgm_keys_chksum_content_error:
        return "SRK checksum invalid content";
    case error_pgm_keys_mismatch_checksum:
        return "SRK checksum mismatch";
    case error_pgm_keys_mismatch_filename:
        return "SRM checksum mismatch filename";
    case error_pgm_keys_already_programmed:
        return "SRK keys already programmed in the OTP";
    case error_pgm_keys_pgm_fail:
        return "SRK key burn eFUSES failure";
    case error_pgm_keys_efuse_verify:
        return "SRK key burn eFUSES verification failure";
    default:
        return "";
    }
}

// Burn efuses into hardware
static int burn_efuses_from_file(const char *srk_file, trace_t *trace)
{
    if (!sec_configuration_is_open())
    {
        trace_write(trace, error_pgm_keys_already_programmed, 0);
        return error_pgm_keys_already_programmed;
    }
    struct sec_srk_key keys = {};
    if (sec_verify_efuses(&keys))
    {
        trace_write(trace, error_pgm_keys_already_programmed, 0);
        return error_pgm_keys_already_programmed;
    }
    FILE *__attribute__((__cleanup__(file_clean_up))) fil = fopen(srk_file, "r");
    if (!fil)
    {
        trace_write(trace, error_pgm_keys_vfs, -errno);
        return -errno;
    }
    if (fread(keys.srk, sizeof keys.srk, 1, fil) != 1)
    {
        trace_write(trace, error_pgm_keys_vfs, -errno);
        return -errno;
    }
    int error = 0;
    if ((error = sec_burn_srk_keys(&keys)))
    {
        return error;
    }
    // Lock bootloader when keys are successfully programmed
    sec_lock_bootloader();
    return error;
}

/** Program SRK fuses into the RT1051 fuses
 */
int program_keys(const struct program_keys_handle *pgm_handle, trace_list_t *tl)
{
    int err;
    if (!pgm_handle)
    {
        printf("pgm_keys: Empty handle\n");
        return -EINVAL;
    }
    if (!pgm_handle->srk_file)
    {
        printf("pgm_keys: srk_file not provided\n");
        return -EINVAL;
    }
    if (!pgm_handle->chksum_srk_file)
    {
        printf("pgm_keys: chksum_srk_file not provided\n");
        return -EINVAL;
    }
    trace_t *trace = trace_append(__PRETTY_FUNCTION__, tl, strerror_pgm_keys, strerror_ext_pgm_keys);
    struct stat st;
    if ((err = stat(pgm_handle->srk_file, &st)))
    {
        if (errno != ENOENT)
        {
            trace_write(trace, error_pgm_keys_vfs, -errno);
        }
        else
        {
            trace_write(trace, error_pgm_keys_no_srk_file, 0);
        }
        return -errno;
    }
    if (!S_ISREG(st.st_mode))
    {
        trace_write(trace, error_pgm_keys_no_srk_file, 0);
        return error_pgm_keys_no_srk_file;
    }
    static const off_t srk_file_size = 32U;
    if (st.st_size != srk_file_size)
    {
        trace_write(trace, error_pgm_keys_srk_key_size_error, 0);
        return error_pgm_keys_srk_key_size_error;
    }
    if ((err = stat(pgm_handle->chksum_srk_file, &st)))
    {
        if (errno != ENOENT)
        {
            trace_write(trace, error_pgm_keys_no_sum_file, -errno);
        }
        else
        {
            trace_write(trace, error_pgm_keys_no_sum_file, 0);
        }
        return -errno;
    }
    if (!S_ISREG(st.st_mode))
    {
        trace_write(trace, error_pgm_keys_no_sum_file, 0);
        return error_pgm_keys_no_sum_file;
    }
    static const off_t chksum_file_size = 32U;
    if (st.st_size < chksum_file_size)
    {
        trace_write(trace, error_pgm_keys_chksum_file_size_error, 0);
        return error_pgm_keys_chksum_file_size_error;
    }
    if ((err = validate_checksum_srk_file(pgm_handle->srk_file, pgm_handle->chksum_srk_file, trace)))
    {
        trace_write(trace, error_pgm_keys_pgm_fail, 0);
        return err;
    }
    if ((err = burn_efuses_from_file(pgm_handle->srk_file, trace)))
    {
        trace_write(trace, error_pgm_keys_efuse_verify, 0);
        return err;
    }
    return err;
}

// Check if key programming is needed
bool program_keys_is_needed(const struct program_keys_handle *pgm_handle)
{
    if (!sec_configuration_is_open())
    {
        return false;
    }
    struct stat st;
    if (stat(pgm_handle->srk_file, &st))
    {
        return false;
    }
    return true;
}